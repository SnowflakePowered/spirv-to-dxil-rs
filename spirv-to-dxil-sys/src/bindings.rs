/* automatically generated by rust-bindgen 0.64.0 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const DXIL_SPIRV_MAX_VIEWPORT: u32 = 16;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum dxil_shader_model {
    ShaderModel6_0 = 393216,
    ShaderModel6_1 = 393217,
    ShaderModel6_2 = 393218,
    ShaderModel6_3 = 393219,
    ShaderModel6_4 = 393220,
    ShaderModel6_5 = 393221,
    ShaderModel6_6 = 393222,
    ShaderModel6_7 = 393223,
    ShaderModel6_8 = 393224,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum dxil_validator_version {
    None = 0,
    Validator1_0 = 65536,
    Validator1_1 = 65537,
    Validator1_2 = 65538,
    Validator1_3 = 65539,
    Validator1_4 = 65540,
    Validator1_5 = 65541,
    Validator1_6 = 65542,
    Validator1_7 = 65543,
    Validator1_8 = 65544,
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum dxil_spirv_shader_stage {
    None = -1,
    Vertex = 0,
    TesselationControl = 1,
    TesselationEvaluation = 2,
    Geometry = 3,
    Fragment = 4,
    Compute = 5,
    Kernel = 14,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dxil_spirv_const_value {
    pub b: bool,
    pub f32_: f32,
    pub f64_: f64,
    pub i8_: i8,
    pub u8_: u8,
    pub i16_: i16,
    pub u16_: u16,
    pub i32_: i32,
    pub u32_: u32,
    pub i64_: i64,
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_dxil_spirv_const_value() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_const_value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_const_value>(),
        8usize,
        concat!("Size of: ", stringify!(dxil_spirv_const_value))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_const_value>(),
        8usize,
        concat!("Alignment of ", stringify!(dxil_spirv_const_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(i8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_const_value),
            "::",
            stringify!(u64_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dxil_spirv_specialization {
    pub id: u32,
    pub value: dxil_spirv_const_value,
    pub defined_on_module: bool,
}
#[test]
fn bindgen_test_layout_dxil_spirv_specialization() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_specialization> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_specialization>(),
        24usize,
        concat!("Size of: ", stringify!(dxil_spirv_specialization))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_specialization>(),
        8usize,
        concat!("Alignment of ", stringify!(dxil_spirv_specialization))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_specialization),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_specialization),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defined_on_module) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_specialization),
            "::",
            stringify!(defined_on_module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_metadata {
    pub requires_runtime_data: bool,
}
#[test]
fn bindgen_test_layout_dxil_spirv_metadata() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_metadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_metadata>(),
        1usize,
        concat!("Size of: ", stringify!(dxil_spirv_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_metadata>(),
        1usize,
        concat!("Alignment of ", stringify!(dxil_spirv_metadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requires_runtime_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_metadata),
            "::",
            stringify!(requires_runtime_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_object {
    pub metadata: dxil_spirv_metadata,
    pub binary: dxil_spirv_object__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_object__bindgen_ty_1 {
    pub buffer: *mut ::std::os::raw::c_void,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_dxil_spirv_object__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_object__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_object__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(dxil_spirv_object__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_object__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(dxil_spirv_object__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_object__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_object__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_dxil_spirv_object() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_object>(),
        24usize,
        concat!("Size of: ", stringify!(dxil_spirv_object))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_object>(),
        8usize,
        concat!("Alignment of ", stringify!(dxil_spirv_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_object),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binary) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_object),
            "::",
            stringify!(binary)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_compute_runtime_data {
    pub group_count_x: u32,
    pub group_count_y: u32,
    pub group_count_z: u32,
    pub padding0: u32,
    pub base_group_x: u32,
    pub base_group_y: u32,
    pub base_group_z: u32,
}
#[test]
fn bindgen_test_layout_dxil_spirv_compute_runtime_data() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_compute_runtime_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_compute_runtime_data>(),
        28usize,
        concat!("Size of: ", stringify!(dxil_spirv_compute_runtime_data))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_compute_runtime_data>(),
        4usize,
        concat!("Alignment of ", stringify!(dxil_spirv_compute_runtime_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_count_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(group_count_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_count_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(group_count_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_count_z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(group_count_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(padding0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_group_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(base_group_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_group_y) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(base_group_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_group_z) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_compute_runtime_data),
            "::",
            stringify!(base_group_z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dxil_spirv_vertex_runtime_data {
    pub first_vertex: u32,
    pub base_instance: u32,
    pub is_indexed_draw: bool,
    pub _dxil_spirv_anon1: dxil_spirv_vertex_runtime_data__bindgen_ty_1,
    pub draw_id: u32,
    pub viewport_width: f32,
    pub viewport_height: f32,
    pub view_index: u32,
    pub depth_bias: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dxil_spirv_vertex_runtime_data__bindgen_ty_1 {
    pub yz_flip_mask: u32,
    pub _dxil_spirv_anon1: dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1 {
    pub y_flip_mask: u16,
    pub z_flip_mask: u16,
}
#[test]
fn bindgen_test_layout_dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_flip_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y_flip_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_flip_mask) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z_flip_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_dxil_spirv_vertex_runtime_data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_vertex_runtime_data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_vertex_runtime_data__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_vertex_runtime_data__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yz_flip_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data__bindgen_ty_1),
            "::",
            stringify!(yz_flip_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_dxil_spirv_vertex_runtime_data() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_vertex_runtime_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_vertex_runtime_data>(),
        36usize,
        concat!("Size of: ", stringify!(dxil_spirv_vertex_runtime_data))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_vertex_runtime_data>(),
        4usize,
        concat!("Alignment of ", stringify!(dxil_spirv_vertex_runtime_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_vertex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(first_vertex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(base_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_indexed_draw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(is_indexed_draw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).draw_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(draw_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewport_width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(viewport_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewport_height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(viewport_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_index) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(view_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth_bias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_vertex_runtime_data),
            "::",
            stringify!(depth_bias)
        )
    );
}
impl dxil_spirv_yz_flip_mode {
    pub const YZ_FLIP_NONE: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(0);
}
impl dxil_spirv_yz_flip_mode {
    pub const Y_FLIP_UNCONDITIONAL: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(1);
}
impl dxil_spirv_yz_flip_mode {
    pub const Z_FLIP_UNCONDITIONAL: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(2);
}
impl dxil_spirv_yz_flip_mode {
    pub const YZ_FLIP_UNCONDITIONAL: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(3);
}
impl dxil_spirv_yz_flip_mode {
    pub const Y_FLIP_CONDITIONAL: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(4);
}
impl dxil_spirv_yz_flip_mode {
    pub const Z_FLIP_CONDITIONAL: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(8);
}
impl dxil_spirv_yz_flip_mode {
    pub const YZ_FLIP_CONDITIONAL: dxil_spirv_yz_flip_mode = dxil_spirv_yz_flip_mode(12);
}
impl ::std::ops::BitOr<dxil_spirv_yz_flip_mode> for dxil_spirv_yz_flip_mode {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        dxil_spirv_yz_flip_mode(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for dxil_spirv_yz_flip_mode {
    #[inline]
    fn bitor_assign(&mut self, rhs: dxil_spirv_yz_flip_mode) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<dxil_spirv_yz_flip_mode> for dxil_spirv_yz_flip_mode {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        dxil_spirv_yz_flip_mode(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for dxil_spirv_yz_flip_mode {
    #[inline]
    fn bitand_assign(&mut self, rhs: dxil_spirv_yz_flip_mode) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct dxil_spirv_yz_flip_mode(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_runtime_conf {
    pub runtime_data_cbv: dxil_spirv_runtime_conf_runtime_cbv,
    pub push_constant_cbv: dxil_spirv_runtime_conf_push_cbv,
    pub zero_based_vertex_instance_id: bool,
    pub zero_based_compute_workgroup_id: bool,
    pub yz_flip: dxil_spirv_runtime_conf_flip_conf,
    pub declared_read_only_images_as_srvs: bool,
    pub inferred_read_only_images_as_srvs: bool,
    pub force_sample_rate_shading: bool,
    pub lower_view_index: bool,
    pub lower_view_index_to_rt_layer: bool,
    pub shader_model_max: dxil_shader_model,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_runtime_conf_runtime_cbv {
    pub register_space: u32,
    pub base_shader_register: u32,
}
#[test]
fn bindgen_test_layout_dxil_spirv_runtime_conf_runtime_cbv() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_runtime_conf_runtime_cbv> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_runtime_conf_runtime_cbv>(),
        8usize,
        concat!("Size of: ", stringify!(dxil_spirv_runtime_conf_runtime_cbv))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_runtime_conf_runtime_cbv>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dxil_spirv_runtime_conf_runtime_cbv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_runtime_cbv),
            "::",
            stringify!(register_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_shader_register) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_runtime_cbv),
            "::",
            stringify!(base_shader_register)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_runtime_conf_push_cbv {
    pub register_space: u32,
    pub base_shader_register: u32,
}
#[test]
fn bindgen_test_layout_dxil_spirv_runtime_conf_push_cbv() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_runtime_conf_push_cbv> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_runtime_conf_push_cbv>(),
        8usize,
        concat!("Size of: ", stringify!(dxil_spirv_runtime_conf_push_cbv))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_runtime_conf_push_cbv>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dxil_spirv_runtime_conf_push_cbv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_push_cbv),
            "::",
            stringify!(register_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_shader_register) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_push_cbv),
            "::",
            stringify!(base_shader_register)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_runtime_conf_flip_conf {
    pub mode: dxil_spirv_yz_flip_mode,
    pub y_mask: u16,
    pub z_mask: u16,
}
#[test]
fn bindgen_test_layout_dxil_spirv_runtime_conf_flip_conf() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_runtime_conf_flip_conf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_runtime_conf_flip_conf>(),
        8usize,
        concat!("Size of: ", stringify!(dxil_spirv_runtime_conf_flip_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_runtime_conf_flip_conf>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dxil_spirv_runtime_conf_flip_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_flip_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_flip_conf),
            "::",
            stringify!(y_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_mask) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf_flip_conf),
            "::",
            stringify!(z_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_dxil_spirv_runtime_conf() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_runtime_conf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_runtime_conf>(),
        40usize,
        concat!("Size of: ", stringify!(dxil_spirv_runtime_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_runtime_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(dxil_spirv_runtime_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).runtime_data_cbv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(runtime_data_cbv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).push_constant_cbv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(push_constant_cbv)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).zero_based_vertex_instance_id) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(zero_based_vertex_instance_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).zero_based_compute_workgroup_id) as usize - ptr as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(zero_based_compute_workgroup_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yz_flip) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(yz_flip)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).declared_read_only_images_as_srvs) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(declared_read_only_images_as_srvs)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inferred_read_only_images_as_srvs) as usize - ptr as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(inferred_read_only_images_as_srvs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_sample_rate_shading) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(force_sample_rate_shading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_view_index) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(lower_view_index)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lower_view_index_to_rt_layer) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(lower_view_index_to_rt_layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shader_model_max) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_runtime_conf),
            "::",
            stringify!(shader_model_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_debug_options {
    pub dump_nir: bool,
}
#[test]
fn bindgen_test_layout_dxil_spirv_debug_options() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_debug_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_debug_options>(),
        1usize,
        concat!("Size of: ", stringify!(dxil_spirv_debug_options))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_debug_options>(),
        1usize,
        concat!("Alignment of ", stringify!(dxil_spirv_debug_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_nir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_debug_options),
            "::",
            stringify!(dump_nir)
        )
    );
}
pub type dxil_spirv_msg_callback = ::std::option::Option<
    unsafe extern "C" fn(priv_: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dxil_spirv_logger {
    pub priv_: *mut ::std::os::raw::c_void,
    pub log: dxil_spirv_msg_callback,
}
#[test]
fn bindgen_test_layout_dxil_spirv_logger() {
    const UNINIT: ::std::mem::MaybeUninit<dxil_spirv_logger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dxil_spirv_logger>(),
        16usize,
        concat!("Size of: ", stringify!(dxil_spirv_logger))
    );
    assert_eq!(
        ::std::mem::align_of::<dxil_spirv_logger>(),
        8usize,
        concat!("Alignment of ", stringify!(dxil_spirv_logger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_logger),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dxil_spirv_logger),
            "::",
            stringify!(log)
        )
    );
}
extern "C" {
    #[doc = " Compile a SPIR-V module into DXIL.\n \\param  words  SPIR-V module to compile\n \\param  word_count  number of words in the SPIR-V module\n \\param  specializations  specialization constants to compile with the shader\n \\param  num_specializations  number of specialization constants\n \\param  stage  shader stage\n \\param  entry_point_name  name of shader entrypoint\n \\param  conf  configuration for spriv_to_dxil\n \\param  out_dxil  will contain the DXIL bytes on success (call spirv_to_dxil_free after use)\n \\return  true if compilation succeeded"]
    pub fn spirv_to_dxil(
        words: *const u32,
        word_count: usize,
        specializations: *mut dxil_spirv_specialization,
        num_specializations: ::std::os::raw::c_uint,
        stage: dxil_spirv_shader_stage,
        entry_point_name: *const ::std::os::raw::c_char,
        validator_version_max: dxil_validator_version,
        debug_options: *const dxil_spirv_debug_options,
        conf: *const dxil_spirv_runtime_conf,
        logger: *const dxil_spirv_logger,
        out_dxil: *mut dxil_spirv_object,
    ) -> bool;
}
extern "C" {
    #[doc = " Free the buffer allocated by spirv_to_dxil."]
    pub fn spirv_to_dxil_free(dxil: *mut dxil_spirv_object);
}
extern "C" {
    pub fn spirv_to_dxil_get_version() -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
